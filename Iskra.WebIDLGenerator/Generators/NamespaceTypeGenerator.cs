using System.Collections.Immutable;
using Iskra.WebIDLGenerator.Extensions;
using Iskra.WebIDLGenerator.Models;
using Microsoft.Extensions.DependencyInjection;

namespace Iskra.WebIDLGenerator.Generators;

public class NamespaceTypeGenerator(
    IServiceProvider provider,
    GenSettings genSettings,
    GenTypeDescriptors descriptors
)
{
    public string Generate(NamespaceType input)
    {
        var memberTypeGenerator = provider.GetRequiredService<MemberTypeGenerator>();

        var className = $"{input.Name.CapitalizeFirstLetter()}Namespace";
        var propertyName = $"{input.Name.CapitalizeFirstLetter()}";

        List<string> bodyParts = [];

        foreach (var idlInterfaceMemberType in input.Members)
        {
            var part = memberTypeGenerator.Generate(idlInterfaceMemberType, input.Name);
            if (!string.IsNullOrEmpty(part))
            {
                bodyParts.Add(part);
            }
        }

        List<string> exposedInterfacesParts = [];
        var exposedDescriptors = FindExposedDescriptors(input);
        foreach (var desc in exposedDescriptors)
        {
            if (desc.Namespace != genSettings.Namespace)
            {
                throw new Exception("You can only expose to interfaces in the same namespace.");
            }

            if (desc.RootType is not InterfaceType interfaceType)
            {
                throw new Exception("You can only expose to interface type.");
            }

            exposedInterfacesParts.Add(
                $$"""
                  public partial class {{interfaceType.Name}}
                  {
                      public global::{{genSettings.Namespace}}.{{className}} {{propertyName}} => new global::{{genSettings.Namespace}}.{{className}}(global::Iskra.JSCore.Extensions.JSObjectPropertyExtensions.GetPropertyAsJSObjectV2(JSObject, "{{input.Name}}"));
                  }
                  """
            );
        }


        var body = string.Join("\n\n", bodyParts);
        var exposedInterfaces = string.Join("\n\n", exposedInterfacesParts);

        var content = $$"""
                        // <auto-generated/>

                        namespace {{genSettings.Namespace}};

                        #nullable enable

                        public partial class {{className}}(global::System.Runtime.InteropServices.JavaScript.JSObject obj): global::Iskra.JSCore.JSObjectProxy(obj)
                        {
                        {{body.IndentLines(4)}}
                        }

                        {{exposedInterfaces}}

                        #nullable disable
                        """;

        return content;
    }

    private List<GenTypeDescriptor> FindExposedDescriptors(NamespaceType input)
    {
        var exposed = input.ExtAttrs
            .Where(attr => attr.Name == "Exposed")
            .SelectMany(x => x.Rhs switch
            {
                ExtendedAttributeRightHandSideIdentifier identifier => [identifier.Value],
                ExtendedAttributeRightHandSideIdentifierList identifierList => identifierList.Value.Select(x =>
                    x.Value),
                ExtendedAttributeRightHandSideWildCard => ["*"],
                _ => throw new Exception(
                    "Global attribute is invalid. Only identifier, identifier-list or wildcard are allowed.")
            })
            .ToImmutableHashSet();

        return descriptors.Descriptors
            .Where(desc => desc.RootType is InterfaceType interfaceType && IsExposedTo(interfaceType))
            .ToList();

        bool IsExposedTo(InterfaceType interfaceType)
        {
            var globals = interfaceType.ExtAttrs.Where(attr => attr.Name == "Global")
                .SelectMany(x => x.Rhs switch
                {
                    ExtendedAttributeRightHandSideIdentifier identifier => [identifier.Value],
                    ExtendedAttributeRightHandSideIdentifierList identifierList => identifierList.Value.Select(x =>
                        x.Value),
                    _ => throw new Exception(
                        "Global attribute is invalid. Only identifier or identifier-list are allowed.")
                })
                .ToImmutableHashSet();

            if (globals.Count == 0)
            {
                return false;
            }

            return exposed.Contains("*") || globals.Any(exposed.Contains);
        }
    }
}