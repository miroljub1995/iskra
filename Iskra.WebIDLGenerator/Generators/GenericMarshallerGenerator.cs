using Iskra.StdWebGenerator.GeneratorContexts;
using Iskra.WebIDLGenerator.Extensions;
using Iskra.WebIDLGenerator.Models;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace Iskra.WebIDLGenerator.Generators;

public class GenericMarshallerGenerator(
    IServiceProvider provider,
    GenSettings genSettings,
    GeneratorContext generatorContext,
    ILogger<GenericMarshallerGenerator> logger
)
{
    private readonly List<KeyValuePair<IDLTypeDescription, string>> _marshallers = [];

    public async Task GenerateAsync(CancellationToken cancellationToken = default)
    {
        var content = $$"""
                        // <auto-generated/>

                        using System.Runtime.InteropServices.JavaScript;

                        namespace {{genSettings.Namespace}};

                        #nullable enable

                        public static partial class GenericMarshaller
                        {
                            [global::System.Runtime.InteropServices.JavaScript.JSImportAttribute("construct", "iskra")]
                            private static partial global::System.Runtime.InteropServices.JavaScript.JSObject ConstructArray(JSObject obj, string constructorName, int length);

                        {{GenerateFrozenArrayClass().IndentLines(4)}}

                        {{GenerateSequenceClass().IndentLines(4)}}

                        {{GenerateUnionClass().IndentLines(4)}}
                        }

                        #nullable disable
                        """;


        var outputFile = Path.GetFullPath(Path.Combine(genSettings.Output, "GenericMarshaller.cs"));
        if (File.Exists(outputFile))
        {
            throw new Exception($"Output file {outputFile} already exists.");
        }

        await File.WriteAllTextAsync(outputFile, content, cancellationToken);
    }

    public string GetOrCreateMarshaller(IDLTypeDescription input)
    {
        var found = TryFind(input);
        if (found is not null)
        {
            return found;
        }

        var name = input switch
        {
            FrozenArrayTypeDescription => $"global::{genSettings.Namespace}.GenericMarshaller.FrozenArray",
            SequenceTypeDescription => $"global::{genSettings.Namespace}.GenericMarshaller.Sequence",
            UnionTypeDescription => $"global::{genSettings.Namespace}.GenericMarshaller.Union",
            _ => throw new NotSupportedException($"Type {input} is not supported.")
        };

        _marshallers.Add(new KeyValuePair<IDLTypeDescription, string>(input, name));

        return name;
    }

    private string? TryFind(IDLTypeDescription input)
    {
        foreach (var kvp in _marshallers)
        {
            if (AreEqual(input, kvp.Key))
            {
                return kvp.Value;
            }
        }

        return null;
    }

    private bool AreEqual(IDLTypeDescription a, IDLTypeDescription b)
    {
        if (a.Nullable != b.Nullable)
        {
            return false;
        }

        // if (a.ExtAttrs.Count != b.ExtAttrs.Count)
        // {
        //     return false;
        // }
        //
        // for (var i = 0; i < a.ExtAttrs.Count; i++)
        // {
        //     if (!AreEqual(a.ExtAttrs[i], b.ExtAttrs[i]))
        //     {
        //         return false;
        //     }
        // }

        if (a is UnionTypeDescription unionA && b is UnionTypeDescription unionB)
        {
            return AreEqual(unionA.IdlType, unionB.IdlType);
        }

        if (a is SingleTypeDescription singleA && b is SingleTypeDescription singleB)
        {
            var typeA = singleA.IdlType switch
            {
                BuiltinTypes.UnrestrictedDouble => BuiltinTypes.Double,
                BuiltinTypes.UnrestrictedFloat => BuiltinTypes.Float,
                _ => singleA.IdlType
            };

            var typeB = singleB.IdlType switch
            {
                BuiltinTypes.UnrestrictedDouble => BuiltinTypes.Double,
                BuiltinTypes.UnrestrictedFloat => BuiltinTypes.Float,
                _ => singleB.IdlType
            };

            return typeA == typeB;
        }

        if (a is FrozenArrayTypeDescription frozenA && b is FrozenArrayTypeDescription frozenB)
        {
            return AreEqual(frozenA.IdlType, frozenB.IdlType);
        }

        if (a is ObservableArrayTypeDescription observableA && b is ObservableArrayTypeDescription observableB)
        {
            return AreEqual(observableA.IdlType, observableB.IdlType);
        }

        if (a is PromiseTypeDescription promiseA && b is PromiseTypeDescription promiseB)
        {
            return AreEqual(promiseA.IdlType, promiseB.IdlType);
        }

        if (a is RecordTypeDescription recordA && b is RecordTypeDescription recordB)
        {
            return AreEqual(recordA.IdlType, recordB.IdlType);
        }

        if (a is SequenceTypeDescription sequenceA && b is SequenceTypeDescription sequenceB)
        {
            return AreEqual(sequenceA.IdlType, sequenceB.IdlType);
        }

        return false;
    }


    private bool AreEqual(List<IDLTypeDescription> a, List<IDLTypeDescription> b)
    {
        if (a.Count != b.Count)
        {
            return false;
        }

        for (var i = 0; i < a.Count; i++)
        {
            if (!AreEqual(a[i], b[i]))
            {
                return false;
            }
        }

        return true;
    }

    private string GenerateFrozenArrayClass()
    {
        var toTypeDeclarationGenerator = provider.GetRequiredService<IDLTypeDescriptionToTypeDeclarationGenerator>();

        List<string> interfaceParts = [];
        List<string> bodyParts = [];
        foreach (var marshaller in _marshallers)
        {
            if (marshaller.Key is not FrozenArrayTypeDescription)
            {
                continue;
            }

            var toManaged = GenerateToManaged(marshaller.Key);
            var toJS = GenerateToJS(marshaller.Key);

            var marshalledType = toTypeDeclarationGenerator.Generate(marshaller.Key, true);

            var interfacePart = $"global::Iskra.JSCore.Generics.IGenericMarshaller<{marshalledType}>";
            interfaceParts.Add(interfacePart);

            var bodyPart = $$"""
                             static {{marshalledType}} {{interfacePart}}.ToManaged(JSObject input)
                             {
                             {{toManaged.IndentLines(4)}}
                             }

                             static JSObject {{interfacePart}}.ToJS({{marshalledType}} input)
                             {
                             {{toJS.IndentLines(4)}}
                             }
                             """;

            bodyParts.Add(bodyPart);
        }

        var interfaces = string.Join(",\n", interfaceParts);
        var body = string.Join("\n\n", bodyParts);

        var content = $$"""
                        public class FrozenArray:
                        {{interfaces.IndentLines(4)}}
                        {
                        {{body.IndentLines(4)}}
                        }
                        """;

        return content;
    }

    private string GenerateSequenceClass()
    {
        var toTypeDeclarationGenerator = provider.GetRequiredService<IDLTypeDescriptionToTypeDeclarationGenerator>();

        List<string> interfaceParts = [];
        List<string> bodyParts = [];
        foreach (var marshaller in _marshallers)
        {
            if (marshaller.Key is not SequenceTypeDescription)
            {
                continue;
            }

            var toManaged = GenerateToManaged(marshaller.Key);
            var toJS = GenerateToJS(marshaller.Key);

            var marshalledType = toTypeDeclarationGenerator.Generate(marshaller.Key, true);

            var interfacePart = $"global::Iskra.JSCore.Generics.IGenericMarshaller<{marshalledType}>";
            interfaceParts.Add(interfacePart);

            var bodyPart = $$"""
                             static {{marshalledType}} {{interfacePart}}.ToManaged(JSObject input)
                             {
                             {{toManaged.IndentLines(4)}}
                             }

                             static JSObject {{interfacePart}}.ToJS({{marshalledType}} input)
                             {
                             {{toJS.IndentLines(4)}}
                             }
                             """;

            bodyParts.Add(bodyPart);
        }

        var interfaces = string.Join(",\n", interfaceParts);
        var body = string.Join("\n\n", bodyParts);

        var content = $$"""
                        public class Sequence:
                        {{interfaces.IndentLines(4)}}
                        {
                        {{body.IndentLines(4)}}
                        }
                        """;

        return content;
    }

    private string GenerateUnionClass()
    {
        var toTypeDeclarationGenerator = provider.GetRequiredService<IDLTypeDescriptionToTypeDeclarationGenerator>();

        List<IDLTypeDescription> distinctItems = [];
        List<string> interfaceParts = [];
        List<string> bodyParts = [];
        foreach (var marshaller in _marshallers)
        {
            if (marshaller.Key is not UnionTypeDescription unionTypeDescription)
            {
                continue;
            }

            foreach (var itemType in unionTypeDescription.IdlType)
            {
                if (distinctItems.Any(x => AreEqual(x, itemType)))
                {
                    continue;
                }

                distinctItems.Add(itemType);

                // var toManaged = GenerateToManaged(marshaller.Key);
                var toManaged = "throw new NotImplementedException();";
                // var toJS = GenerateToJS(marshaller.Key);
                var toJS = "throw new NotImplementedException();";

                var marshalledType = toTypeDeclarationGenerator.Generate(itemType);

                var interfacePart = $"global::Iskra.JSCore.Generics.IUnionTypeMarshaller<{marshalledType}>";
                interfaceParts.Add(interfacePart);

                var bodyPart = $$"""
                                 static bool {{interfacePart}}.TryToManaged(JSObject input, [global::System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] out {{marshalledType}} value)
                                 {
                                 {{toManaged.IndentLines(4)}}
                                 }

                                 static JSObject {{interfacePart}}.ToJS({{marshalledType}} input)
                                 {
                                 {{toJS.IndentLines(4)}}
                                 }
                                 """;

                bodyParts.Add(bodyPart);
            }
        }

        var interfaces = string.Join(",\n", interfaceParts);
        var body = string.Join("\n\n", bodyParts);

        var content = $$"""
                        public class Union:
                        {{interfaces.IndentLines(4)}}
                        {
                        {{body.IndentLines(4)}}
                        }
                        """;

        return content;
    }

    private string GenerateToManaged(IDLTypeDescription input)
    {
        var toTypeDeclarationGenerator = provider.GetRequiredService<IDLTypeDescriptionToTypeDeclarationGenerator>();
        var getPropertyValueGenerator = provider.GetRequiredService<GetPropertyValueGenerator>();

        if (input is FrozenArrayTypeDescription frozenArray)
        {
            var elementType = frozenArray.IdlType.Single();
            var returnTypeDeclaration = toTypeDeclarationGenerator.Generate(input, true);
            var elementTypeDeclaration = toTypeDeclarationGenerator.Generate(elementType);

            var resVar = generatorContext.GetNextVariableName("res");
            var doubleLengthVar = generatorContext.GetNextVariableName("doubleLength");
            var lengthVar = generatorContext.GetNextVariableName("length");
            var indexVar = generatorContext.GetNextVariableName("i");
            var elementVar = generatorContext.GetNextVariableName("element");

            var getElementContent = getPropertyValueGenerator.Generate(
                inputVar: "input",
                type: elementType,
                propertyNameVar: $"{indexVar}.ToString()",
                isStatic: false,
                containingTypeName: "Array",
                outputVar: elementVar
            );

            return $$"""
                     double {{doubleLengthVar}} = global::Iskra.JSCore.Extensions.JSObjectPropertyExtensions.GetPropertyAsDoubleV2(input, "length");
                     int {{lengthVar}} = global::System.Convert.ToInt32({{doubleLengthVar}});

                     {{returnTypeDeclaration}} {{resVar}} = new {{elementTypeDeclaration}}[{{lengthVar}}];
                     for (int {{indexVar}} = 0; {{indexVar}} < {{lengthVar}}; {{indexVar}}++)
                     {
                         {{elementTypeDeclaration}} {{elementVar}};
                     {{getElementContent.IndentLines(4)}}
                         {{resVar}}[{{indexVar}}] = {{elementVar}};
                     }

                     return {{resVar}};
                     """;
        }

        if (input is SequenceTypeDescription sequence)
        {
            var elementType = sequence.IdlType.Single();
            var returnTypeDeclaration = toTypeDeclarationGenerator.Generate(input, true);
            var elementTypeDeclaration = toTypeDeclarationGenerator.Generate(elementType);

            var resVar = generatorContext.GetNextVariableName("res");
            var doubleLengthVar = generatorContext.GetNextVariableName("doubleLength");
            var lengthVar = generatorContext.GetNextVariableName("length");
            var indexVar = generatorContext.GetNextVariableName("i");
            var elementVar = generatorContext.GetNextVariableName("element");

            var getElementContent = getPropertyValueGenerator.Generate(
                inputVar: "input",
                type: elementType,
                propertyNameVar: $"{indexVar}.ToString()",
                isStatic: false,
                containingTypeName: "Array",
                outputVar: elementVar
            );

            return $$"""
                     double {{doubleLengthVar}} = global::Iskra.JSCore.Extensions.JSObjectPropertyExtensions.GetPropertyAsDoubleV2(input, "length");
                     int {{lengthVar}} = global::System.Convert.ToInt32({{doubleLengthVar}});

                     {{returnTypeDeclaration}} {{resVar}} = new {{elementTypeDeclaration}}[{{lengthVar}}];
                     for (int {{indexVar}} = 0; {{indexVar}} < {{lengthVar}}; {{indexVar}}++)
                     {
                         {{elementTypeDeclaration}} {{elementVar}};
                     {{getElementContent.IndentLines(4)}}
                         {{resVar}}[{{indexVar}}] = {{elementVar}};
                     }

                     return {{resVar}};
                     """;
        }

        logger.LogWarning("GenericMarshaller ToManaged for type {input} not supported.", input);
        return "throw new NotImplementedException();";
    }

    private string GenerateToJS(IDLTypeDescription input)
    {
        var setPropertyValueGenerator = provider.GetRequiredService<SetPropertyValueGenerator>();

        if (input is FrozenArrayTypeDescription frozenArray)
        {
            var elementType = frozenArray.IdlType.Single();
            var resVar = generatorContext.GetNextVariableName("res");
            var indexVar = generatorContext.GetNextVariableName("i");

            var setElementContent = setPropertyValueGenerator.Generate(
                inputVar: resVar,
                valueVar: $"input[{indexVar}]",
                type: elementType,
                propertyNameVar: $"{indexVar}.ToString()",
                isStatic: false,
                containingTypeName: "Array"
            );

            return $$"""
                     global::System.Runtime.InteropServices.JavaScript.JSObject {{resVar}} = ConstructArray(global::System.Runtime.InteropServices.JavaScript.JSHost.GlobalThis, "Array", input.Length);

                     for (int {{indexVar}} = 0; {{indexVar}} < input.Length; {{indexVar}}++)
                     {
                     {{setElementContent.IndentLines(4)}}
                     }

                     return {{resVar}};
                     """;
        }

        if (input is SequenceTypeDescription sequence)
        {
            var elementType = sequence.IdlType.Single();
            var resVar = generatorContext.GetNextVariableName("res");
            var indexVar = generatorContext.GetNextVariableName("i");

            var setElementContent = setPropertyValueGenerator.Generate(
                inputVar: resVar,
                valueVar: $"input[{indexVar}]",
                type: elementType,
                propertyNameVar: $"{indexVar}.ToString()",
                isStatic: false,
                containingTypeName: "Array"
            );

            return $$"""
                     global::System.Runtime.InteropServices.JavaScript.JSObject {{resVar}} = ConstructArray(global::System.Runtime.InteropServices.JavaScript.JSHost.GlobalThis, "Array", input.Length);

                     for (int {{indexVar}} = 0; {{indexVar}} < input.Length; {{indexVar}}++)
                     {
                     {{setElementContent.IndentLines(4)}}
                     }

                     return {{resVar}};
                     """;
        }

        logger.LogWarning("GenericMarshaller ToJS for type {input} not supported.", input);
        return "throw new NotImplementedException();";
    }
}