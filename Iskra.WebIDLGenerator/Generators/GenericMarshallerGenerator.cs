using Iskra.StdWebGenerator.GeneratorContexts;
using Iskra.WebIDLGenerator.Extensions;
using Iskra.WebIDLGenerator.Models;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace Iskra.WebIDLGenerator.Generators;

public class GenericMarshallerGenerator(
    IServiceProvider provider,
    GenSettings genSettings,
    GeneratorContext generatorContext,
    ILogger<GenericMarshallerGenerator> logger
)
{
    private readonly List<KeyValuePair<IDLTypeDescription, string>> _marshallers = [];

    public async Task GenerateAsync(CancellationToken cancellationToken = default)
    {
        var content = $$"""
                        // <auto-generated/>

                        namespace {{genSettings.Namespace}};

                        #nullable enable

                        public static partial class GenericMarshaller
                        {
                            [global::System.Runtime.InteropServices.JavaScript.JSImportAttribute("construct", "iskra")]
                            private static partial global::System.Runtime.InteropServices.JavaScript.JSObject ConstructArray(global::System.Runtime.InteropServices.JavaScript.JSObject obj, string constructorName, int length);

                            [global::System.Runtime.InteropServices.JavaScript.JSImportAttribute("construct", "iskra")]
                            private static partial global::System.Runtime.InteropServices.JavaScript.JSObject ConstructObject(global::System.Runtime.InteropServices.JavaScript.JSObject obj, string constructorName);

                        {{GenerateFrozenArrayClass().IndentLines(4)}}

                        {{GenerateSequenceClass().IndentLines(4)}}

                        {{GenerateUnionClass().IndentLines(4)}}
                        }

                        #nullable disable
                        """;


        var outputFile = Path.GetFullPath(Path.Combine(genSettings.Output, "GenericMarshaller.cs"));
        if (File.Exists(outputFile))
        {
            throw new Exception($"Output file {outputFile} already exists.");
        }

        await File.WriteAllTextAsync(outputFile, content, cancellationToken);
    }

    public string GetOrCreateMarshaller(IDLTypeDescription input)
    {
        var found = TryFind(input);
        if (found is not null)
        {
            return found;
        }

        var name = input switch
        {
            FrozenArrayTypeDescription => $"global::{genSettings.Namespace}.GenericMarshaller.FrozenArray",
            SequenceTypeDescription => $"global::{genSettings.Namespace}.GenericMarshaller.Sequence",
            UnionTypeDescription => $"global::{genSettings.Namespace}.GenericMarshaller.Union",
            _ => throw new NotSupportedException($"Type {input} is not supported.")
        };

        _marshallers.Add(new KeyValuePair<IDLTypeDescription, string>(input, name));

        return name;
    }

    private string? TryFind(IDLTypeDescription input)
    {
        foreach (var kvp in _marshallers)
        {
            if (AreEqual(input, kvp.Key))
            {
                return kvp.Value;
            }
        }

        return null;
    }

    private bool AreEqual(IDLTypeDescription a, IDLTypeDescription b)
    {
        if (a.Nullable != b.Nullable)
        {
            return false;
        }

        // if (a.ExtAttrs.Count != b.ExtAttrs.Count)
        // {
        //     return false;
        // }
        //
        // for (var i = 0; i < a.ExtAttrs.Count; i++)
        // {
        //     if (!AreEqual(a.ExtAttrs[i], b.ExtAttrs[i]))
        //     {
        //         return false;
        //     }
        // }

        if (a is UnionTypeDescription unionA && b is UnionTypeDescription unionB)
        {
            return AreEqual(unionA.IdlType, unionB.IdlType);
        }

        if (a is SingleTypeDescription singleA && b is SingleTypeDescription singleB)
        {
            var typeA = singleA.IdlType switch
            {
                BuiltinTypes.UnrestrictedDouble => BuiltinTypes.Double,
                BuiltinTypes.UnrestrictedFloat => BuiltinTypes.Float,
                _ => singleA.IdlType
            };

            var typeB = singleB.IdlType switch
            {
                BuiltinTypes.UnrestrictedDouble => BuiltinTypes.Double,
                BuiltinTypes.UnrestrictedFloat => BuiltinTypes.Float,
                _ => singleB.IdlType
            };

            return typeA == typeB;
        }

        if (a is FrozenArrayTypeDescription frozenA && b is FrozenArrayTypeDescription frozenB)
        {
            return AreEqual(frozenA.IdlType, frozenB.IdlType);
        }

        if (a is ObservableArrayTypeDescription observableA && b is ObservableArrayTypeDescription observableB)
        {
            return AreEqual(observableA.IdlType, observableB.IdlType);
        }

        if (a is PromiseTypeDescription promiseA && b is PromiseTypeDescription promiseB)
        {
            return AreEqual(promiseA.IdlType, promiseB.IdlType);
        }

        if (a is RecordTypeDescription recordA && b is RecordTypeDescription recordB)
        {
            return AreEqual(recordA.IdlType, recordB.IdlType);
        }

        if (a is SequenceTypeDescription sequenceA && b is SequenceTypeDescription sequenceB)
        {
            return AreEqual(sequenceA.IdlType, sequenceB.IdlType);
        }

        return false;
    }


    private bool AreEqual(List<IDLTypeDescription> a, List<IDLTypeDescription> b)
    {
        if (a.Count != b.Count)
        {
            return false;
        }

        for (var i = 0; i < a.Count; i++)
        {
            if (!AreEqual(a[i], b[i]))
            {
                return false;
            }
        }

        return true;
    }

    private string GenerateFrozenArrayClass()
    {
        var toTypeDeclarationGenerator = provider.GetRequiredService<IDLTypeDescriptionToTypeDeclarationGenerator>();

        List<string> interfaceParts = [];
        List<string> bodyParts = [];
        foreach (var marshaller in _marshallers)
        {
            if (marshaller.Key is not FrozenArrayTypeDescription)
            {
                continue;
            }

            var toManaged = GenerateToManaged(marshaller.Key);
            var toJS = GenerateToJS(marshaller.Key);

            var marshalledType = toTypeDeclarationGenerator.Generate(marshaller.Key, true);

            var interfacePart = $"global::Iskra.JSCore.Generics.IGenericMarshaller<{marshalledType}>";
            interfaceParts.Add(interfacePart);

            var bodyPart = $$"""
                             static {{marshalledType}} {{interfacePart}}.ToManaged(global::System.Runtime.InteropServices.JavaScript.JSObject input)
                             {
                             {{toManaged.IndentLines(4)}}
                             }

                             static global::System.Runtime.InteropServices.JavaScript.JSObject {{interfacePart}}.ToJS({{marshalledType}} input)
                             {
                             {{toJS.IndentLines(4)}}
                             }
                             """;

            bodyParts.Add(bodyPart);
        }

        var interfaces = string.Join(",\n", interfaceParts);
        var body = string.Join("\n\n", bodyParts);

        var inheritance = interfaceParts.Count > 0
            ? $$"""
                :
                {{interfaces.IndentLines(4)}}
                """
            : string.Empty;

        var content = $$"""
                        public class FrozenArray{{inheritance}}
                        {
                        {{body.IndentLines(4)}}
                        }
                        """;

        return content;
    }

    private string GenerateSequenceClass()
    {
        var toTypeDeclarationGenerator = provider.GetRequiredService<IDLTypeDescriptionToTypeDeclarationGenerator>();

        List<string> interfaceParts = [];
        List<string> bodyParts = [];
        foreach (var marshaller in _marshallers)
        {
            if (marshaller.Key is not SequenceTypeDescription)
            {
                continue;
            }

            var toManaged = GenerateToManaged(marshaller.Key);
            var toJS = GenerateToJS(marshaller.Key);

            var marshalledType = toTypeDeclarationGenerator.Generate(marshaller.Key, true);

            var interfacePart = $"global::Iskra.JSCore.Generics.IGenericMarshaller<{marshalledType}>";
            interfaceParts.Add(interfacePart);

            var bodyPart = $$"""
                             static {{marshalledType}} {{interfacePart}}.ToManaged(global::System.Runtime.InteropServices.JavaScript.JSObject input)
                             {
                             {{toManaged.IndentLines(4)}}
                             }

                             static global::System.Runtime.InteropServices.JavaScript.JSObject {{interfacePart}}.ToJS({{marshalledType}} input)
                             {
                             {{toJS.IndentLines(4)}}
                             }
                             """;

            bodyParts.Add(bodyPart);
        }

        var interfaces = string.Join(",\n", interfaceParts);
        var body = string.Join("\n\n", bodyParts);

        var inheritance = interfaceParts.Count > 0
            ? $$"""
                :
                {{interfaces.IndentLines(4)}}
                """
            : string.Empty;

        var content = $$"""
                        public class Sequence{{inheritance}}
                        {
                        {{body.IndentLines(4)}}
                        }
                        """;

        return content;
    }

    private string GenerateUnionClass()
    {
        var toTypeDeclarationGenerator = provider.GetRequiredService<IDLTypeDescriptionToTypeDeclarationGenerator>();

        List<IDLTypeDescription> distinctItems = [];
        List<string> interfaceParts = [];
        List<string> bodyParts = [];
        foreach (var marshaller in _marshallers)
        {
            if (marshaller.Key is not UnionTypeDescription unionTypeDescription)
            {
                continue;
            }

            foreach (var itemType in unionTypeDescription.IdlType)
            {
                if (distinctItems.Any(x => AreEqual(x, itemType)))
                {
                    continue;
                }

                distinctItems.Add(itemType);

                var toManaged = GenerateToManagedUnion(itemType);
                var toJS = GenerateToJSUnion(itemType);

                var marshalledType = toTypeDeclarationGenerator.Generate(itemType);

                var interfacePart = $"global::Iskra.JSCore.Generics.IUnionTypeMarshaller<{marshalledType}>";
                interfaceParts.Add(interfacePart);

                var bodyPart = $$"""
                                 static bool {{interfacePart}}.TryToManaged(global::System.Runtime.InteropServices.JavaScript.JSObject input, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute(false)] out {{marshalledType}} value)
                                 {
                                 {{toManaged.IndentLines(4)}}
                                 }

                                 static global::System.Runtime.InteropServices.JavaScript.JSObject {{interfacePart}}.ToJS({{marshalledType}} input)
                                 {
                                 {{toJS.IndentLines(4)}}
                                 }
                                 """;

                bodyParts.Add(bodyPart);
            }
        }

        var interfaces = string.Join(",\n", interfaceParts);
        var body = string.Join("\n\n", bodyParts);

        var inheritance = interfaceParts.Count > 0
            ? $$"""
                :
                {{interfaces.IndentLines(4)}}
                """
            : string.Empty;

        var content = $$"""
                        public class Union{{inheritance}}
                        {
                        {{body.IndentLines(4)}}
                        }
                        """;

        return content;
    }

    private string GenerateToManaged(IDLTypeDescription input)
    {
        var toTypeDeclarationGenerator = provider.GetRequiredService<IDLTypeDescriptionToTypeDeclarationGenerator>();
        var getPropertyValueGenerator = provider.GetRequiredService<GetPropertyValueGenerator>();

        if (input is FrozenArrayTypeDescription frozenArray)
        {
            var elementType = frozenArray.IdlType.Single();
            var returnTypeDeclaration = toTypeDeclarationGenerator.Generate(input, true);
            var elementTypeDeclaration = toTypeDeclarationGenerator.Generate(elementType);

            var resVar = generatorContext.GetNextVariableName("res");
            var doubleLengthVar = generatorContext.GetNextVariableName("doubleLength");
            var lengthVar = generatorContext.GetNextVariableName("length");
            var indexVar = generatorContext.GetNextVariableName("i");
            var elementVar = generatorContext.GetNextVariableName("element");

            var getElementContent = getPropertyValueGenerator.Generate(
                inputVar: "input",
                type: elementType,
                propertyNameVar: indexVar,
                outputVar: elementVar
            );

            return $$"""
                     double {{doubleLengthVar}} = global::Iskra.JSCore.Extensions.JSObjectPropertyExtensions.GetPropertyAsDoubleV2(input, "length");
                     int {{lengthVar}} = global::System.Convert.ToInt32({{doubleLengthVar}});

                     {{returnTypeDeclaration}} {{resVar}} = new {{elementTypeDeclaration}}[{{lengthVar}}];
                     for (int {{indexVar}} = 0; {{indexVar}} < {{lengthVar}}; {{indexVar}}++)
                     {
                         {{elementTypeDeclaration}} {{elementVar}};
                     {{getElementContent.IndentLines(4)}}
                         {{resVar}}[{{indexVar}}] = {{elementVar}};
                     }

                     return {{resVar}};
                     """;
        }

        if (input is SequenceTypeDescription sequence)
        {
            var elementType = sequence.IdlType.Single();
            var returnTypeDeclaration = toTypeDeclarationGenerator.Generate(input, true);
            var elementTypeDeclaration = toTypeDeclarationGenerator.Generate(elementType);

            var resVar = generatorContext.GetNextVariableName("res");
            var doubleLengthVar = generatorContext.GetNextVariableName("doubleLength");
            var lengthVar = generatorContext.GetNextVariableName("length");
            var indexVar = generatorContext.GetNextVariableName("i");
            var elementVar = generatorContext.GetNextVariableName("element");

            var getElementContent = getPropertyValueGenerator.Generate(
                inputVar: "input",
                type: elementType,
                propertyNameVar: indexVar,
                outputVar: elementVar
            );

            return $$"""
                     double {{doubleLengthVar}} = global::Iskra.JSCore.Extensions.JSObjectPropertyExtensions.GetPropertyAsDoubleV2(input, "length");
                     int {{lengthVar}} = global::System.Convert.ToInt32({{doubleLengthVar}});

                     {{returnTypeDeclaration}} {{resVar}} = new {{elementTypeDeclaration}}[{{lengthVar}}];
                     for (int {{indexVar}} = 0; {{indexVar}} < {{lengthVar}}; {{indexVar}}++)
                     {
                         {{elementTypeDeclaration}} {{elementVar}};
                     {{getElementContent.IndentLines(4)}}
                         {{resVar}}[{{indexVar}}] = {{elementVar}};
                     }

                     return {{resVar}};
                     """;
        }

        logger.LogWarning("GenericMarshaller ToManaged for type {input} not supported.", input);
        return "throw new NotImplementedException();";
    }

    private string GenerateToJS(IDLTypeDescription input)
    {
        var setPropertyValueGenerator = provider.GetRequiredService<SetPropertyValueGenerator>();

        if (input is FrozenArrayTypeDescription frozenArray)
        {
            var elementType = frozenArray.IdlType.Single();
            var resVar = generatorContext.GetNextVariableName("res");
            var indexVar = generatorContext.GetNextVariableName("i");

            var setElementContent = setPropertyValueGenerator.Generate(
                inputVar: resVar,
                valueVar: $"input[{indexVar}]",
                type: elementType,
                propertyNameVar: indexVar
            );

            return $$"""
                     global::System.Runtime.InteropServices.JavaScript.JSObject {{resVar}} = ConstructArray(global::System.Runtime.InteropServices.JavaScript.JSHost.GlobalThis, "Array", input.Length);

                     for (int {{indexVar}} = 0; {{indexVar}} < input.Length; {{indexVar}}++)
                     {
                     {{setElementContent.IndentLines(4)}}
                     }

                     return {{resVar}};
                     """;
        }

        if (input is SequenceTypeDescription sequence)
        {
            var elementType = sequence.IdlType.Single();
            var resVar = generatorContext.GetNextVariableName("res");
            var indexVar = generatorContext.GetNextVariableName("i");

            var setElementContent = setPropertyValueGenerator.Generate(
                inputVar: resVar,
                valueVar: $"input[{indexVar}]",
                type: elementType,
                propertyNameVar: indexVar
            );

            return $$"""
                     global::System.Runtime.InteropServices.JavaScript.JSObject {{resVar}} = ConstructArray(global::System.Runtime.InteropServices.JavaScript.JSHost.GlobalThis, "Array", input.Length);

                     for (int {{indexVar}} = 0; {{indexVar}} < input.Length; {{indexVar}}++)
                     {
                     {{setElementContent.IndentLines(4)}}
                     }

                     return {{resVar}};
                     """;
        }

        logger.LogWarning("GenericMarshaller ToJS for type {input} not supported.", input);
        return "throw new NotImplementedException();";
    }


    private string GenerateToManagedUnion(IDLTypeDescription input)
    {
        var typeVar = generatorContext.GetNextVariableName("type");
        string typeCheckContent;
        if (input is SingleTypeDescription { IdlType: BuiltinTypes.Boolean })
        {
            typeCheckContent = $$"""
                                 if ({{typeVar}} != 1)
                                 {
                                     value = default;
                                     return false;
                                 }
                                 """;
        }
        else if (input is SingleTypeDescription
                 {
                     IdlType: BuiltinTypes.Byte or
                     BuiltinTypes.SignedByte or
                     BuiltinTypes.Short or
                     BuiltinTypes.UnsignedShort or
                     BuiltinTypes.Int32 or
                     BuiltinTypes.UnsignedInt32 or
                     BuiltinTypes.Int64 or
                     BuiltinTypes.UnsignedInt64 or
                     BuiltinTypes.Float or
                     BuiltinTypes.UnrestrictedFloat or
                     BuiltinTypes.Double or
                     BuiltinTypes.UnrestrictedDouble
                 })
        {
            typeCheckContent = $$"""
                                 if ({{typeVar}} != 2)
                                 {
                                     value = default;
                                     return false;
                                 }
                                 """;
        }
        else if (input is SingleTypeDescription { IdlType: BuiltinTypes.BigInt })
        {
            typeCheckContent = $$"""
                                 if ({{typeVar}} != 3)
                                 {
                                     value = default;
                                     return false;
                                 }
                                 """;
        }
        else if (input is SingleTypeDescription { IdlType: BuiltinTypes.String })
        {
            typeCheckContent = $$"""
                                 if ({{typeVar}} != 4)
                                 {
                                     value = default;
                                     return false;
                                 }
                                 """;
        }
        else
        {
            typeCheckContent = $$"""
                                 if ({{typeVar}} != 7)
                                 {
                                     value = default;
                                     return false;
                                 }
                                 """;
        }

        var toTypeDeclarationGenerator = provider.GetRequiredService<IDLTypeDescriptionToTypeDeclarationGenerator>();
        var getPropertyValueGenerator = provider.GetRequiredService<GetPropertyValueGenerator>();

        var valueVar = generatorContext.GetNextVariableName("value");
        var getElementContent = getPropertyValueGenerator.Generate(
            inputVar: "input",
            type: input,
            propertyNameVar: "\"value\"",
            outputVar: valueVar
        );

        var typeDeclaration = toTypeDeclarationGenerator.Generate(input);

        return $$"""
                 double {{typeVar}} = global::Iskra.JSCore.Extensions.JSObjectPropertyExtensions.GetPropertyAsDoubleV2(input, "type");
                 {{typeCheckContent}}

                 try
                 {
                     {{typeDeclaration}} {{valueVar}};
                 {{getElementContent.IndentLines(4)}}

                     value = {{valueVar}};
                     return true;
                 }
                 catch
                 {
                     value = default;
                     return false;
                 }
                 """;
    }

    private string GenerateToJSUnion(IDLTypeDescription input)
    {
        var setPropertyValueGenerator = provider.GetRequiredService<SetPropertyValueGenerator>();
        var jsUnionVar = generatorContext.GetNextVariableName("jsUnion");

        var setValueContent = setPropertyValueGenerator.Generate(
            inputVar: jsUnionVar,
            valueVar: "input",
            type: input,
            propertyNameVar: "\"value\""
        );

        return $$"""
                 global::System.Runtime.InteropServices.JavaScript.JSObject {{jsUnionVar}} = global::{{genSettings.Namespace}}.GenericMarshaller.ConstructObject(global::System.Runtime.InteropServices.JavaScript.JSHost.GlobalThis, "Object");
                 {{setValueContent}}
                 return {{jsUnionVar}};
                 """;
    }
}