using Iskra.StdWebGenerator.GeneratorContexts;
using Iskra.WebIDLGenerator.Extensions;
using Iskra.WebIDLGenerator.Models;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace Iskra.WebIDLGenerator.Generators;

public class GenericMarshallerGenerator(
    IServiceProvider provider,
    GenSettings genSettings,
    GeneratorContext generatorContext,
    ILogger<GenericMarshallerGenerator> logger
)
{
    private readonly List<KeyValuePair<IDLTypeDescription, string>> _marshallers = [];

    public async Task GenerateAsync(CancellationToken cancellationToken = default)
    {
        var toTypeDeclarationGenerator = provider.GetRequiredService<IDLTypeDescriptionToTypeDeclarationGenerator>();

        List<string> bodyParts = [];
        foreach (var marshaller in _marshallers)
        {
            var toManaged = GenerateToManaged(marshaller.Key);
            var toJS = GenerateToJS(marshaller.Key);

            var marshalledType = toTypeDeclarationGenerator.Generate(marshaller.Key, true);

            var bodyPart = $$"""
                             public class {{marshaller.Value}}: global::Iskra.JSCore.Generics.IGenericMarshaller<{{marshalledType}}>
                             {
                                 public static {{marshalledType}} ToManaged(JSObject input)
                                 {
                             {{toManaged.IndentLines(8)}}
                                 }

                                 public static JSObject ToJS({{marshalledType}} input)
                                 {
                             {{toJS.IndentLines(8)}}
                                 }
                             }
                             """;

            bodyParts.Add(bodyPart);
        }

        var body = string.Join("\n\n", bodyParts);

        var content = $$"""
                        // <auto-generated/>

                        using System.Runtime.InteropServices.JavaScript;

                        namespace {{genSettings.Namespace}};

                        #nullable enable

                        public static partial class GenericMarshaller
                        {
                            [global::System.Runtime.InteropServices.JavaScript.JSImportAttribute("construct", "iskra")]
                            private static partial global::System.Runtime.InteropServices.JavaScript.JSObject ConstructArray(JSObject obj, string constructorName, int length);

                        {{body.IndentLines(4)}}
                        }

                        #nullable disable
                        """;


        var outputFile = Path.GetFullPath(Path.Combine(genSettings.Output, "GenericMarshaller.cs"));
        if (File.Exists(outputFile))
        {
            throw new Exception($"Output file {outputFile} already exists.");
        }

        await File.WriteAllTextAsync(outputFile, content, cancellationToken);
    }

    public string GetOrCreateMarshaller(IDLTypeDescription input)
    {
        var found = TryFind(input);
        if (found is not null)
        {
            return $"global::{genSettings.Namespace}.GenericMarshaller.{found}";
        }

        var name = $"Value_{_marshallers.Count}";
        _marshallers.Add(new KeyValuePair<IDLTypeDescription, string>(input, name));

        return $"global::{genSettings.Namespace}.GenericMarshaller.{name}";
    }

    private string? TryFind(IDLTypeDescription input)
    {
        foreach (var kvp in _marshallers)
        {
            if (AreEqual(input, kvp.Key))
            {
                return kvp.Value;
            }
        }

        return null;
    }

    private bool AreEqual(IDLTypeDescription a, IDLTypeDescription b)
    {
        if (a.Nullable != b.Nullable)
        {
            return false;
        }

        // if (a.ExtAttrs.Count != b.ExtAttrs.Count)
        // {
        //     return false;
        // }
        //
        // for (var i = 0; i < a.ExtAttrs.Count; i++)
        // {
        //     if (!AreEqual(a.ExtAttrs[i], b.ExtAttrs[i]))
        //     {
        //         return false;
        //     }
        // }

        if (a is UnionTypeDescription unionA && b is UnionTypeDescription unionB)
        {
            return AreEqual(unionA.IdlType, unionB.IdlType);
        }

        if (a is SingleTypeDescription singleA && b is SingleTypeDescription singleB)
        {
            return singleA.IdlType == singleB.IdlType;
        }

        if (a is FrozenArrayTypeDescription frozenA && b is FrozenArrayTypeDescription frozenB)
        {
            return AreEqual(frozenA.IdlType, frozenB.IdlType);
        }

        if (a is ObservableArrayTypeDescription observableA && b is ObservableArrayTypeDescription observableB)
        {
            return AreEqual(observableA.IdlType, observableB.IdlType);
        }

        if (a is PromiseTypeDescription promiseA && b is PromiseTypeDescription promiseB)
        {
            return AreEqual(promiseA.IdlType, promiseB.IdlType);
        }

        if (a is RecordTypeDescription recordA && b is RecordTypeDescription recordB)
        {
            return AreEqual(recordA.IdlType, recordB.IdlType);
        }

        if (a is SequenceTypeDescription sequenceA && b is SequenceTypeDescription sequenceB)
        {
            return AreEqual(sequenceA.IdlType, sequenceB.IdlType);
        }

        return false;
    }


    private bool AreEqual(List<IDLTypeDescription> a, List<IDLTypeDescription> b)
    {
        if (a.Count != b.Count)
        {
            return false;
        }

        for (var i = 0; i < a.Count; i++)
        {
            if (!AreEqual(a[i], b[i]))
            {
                return false;
            }
        }

        return true;
    }

    private string GenerateToManaged(IDLTypeDescription input)
    {
        var toTypeDeclarationGenerator = provider.GetRequiredService<IDLTypeDescriptionToTypeDeclarationGenerator>();
        var getPropertyValueGenerator = provider.GetRequiredService<GetPropertyValueGenerator>();

        if (input is FrozenArrayTypeDescription frozenArray)
        {
            var elementType = frozenArray.IdlType.Single();
            var returnTypeDeclaration = toTypeDeclarationGenerator.Generate(input, true);
            var elementTypeDeclaration = toTypeDeclarationGenerator.Generate(elementType);

            var resVar = generatorContext.GetNextVariableName("res");
            var doubleLengthVar = generatorContext.GetNextVariableName("doubleLength");
            var lengthVar = generatorContext.GetNextVariableName("length");
            var indexVar = generatorContext.GetNextVariableName("i");
            var elementVar = generatorContext.GetNextVariableName("element");

            var getElementContent = getPropertyValueGenerator.Generate(
                inputVar: "input",
                type: elementType,
                propertyNameVar: $"{indexVar}.ToString()",
                isStatic: false,
                containingTypeName: "Array",
                outputVar: elementVar
            );

            return $$"""
                     double {{doubleLengthVar}} = global::Iskra.JSCore.Extensions.JSObjectPropertyExtensions.GetPropertyAsDoubleV2(input, "length");
                     int {{lengthVar}} = global::System.Convert.ToInt32({{doubleLengthVar}});

                     {{returnTypeDeclaration}} {{resVar}} = new {{elementTypeDeclaration}}[{{lengthVar}}];
                     for (int {{indexVar}} = 0; {{indexVar}} < {{lengthVar}}; {{indexVar}}++)
                     {
                         {{elementTypeDeclaration}} {{elementVar}};
                     {{getElementContent.IndentLines(4)}}
                         {{resVar}}[{{indexVar}}] = {{elementVar}};
                     }

                     return {{resVar}};
                     """;
        }

        if (input is SequenceTypeDescription sequence)
        {
            var elementType = sequence.IdlType.Single();
            var returnTypeDeclaration = toTypeDeclarationGenerator.Generate(input, true);
            var elementTypeDeclaration = toTypeDeclarationGenerator.Generate(elementType);

            var resVar = generatorContext.GetNextVariableName("res");
            var doubleLengthVar = generatorContext.GetNextVariableName("doubleLength");
            var lengthVar = generatorContext.GetNextVariableName("length");
            var indexVar = generatorContext.GetNextVariableName("i");
            var elementVar = generatorContext.GetNextVariableName("element");

            var getElementContent = getPropertyValueGenerator.Generate(
                inputVar: "input",
                type: elementType,
                propertyNameVar: $"{indexVar}.ToString()",
                isStatic: false,
                containingTypeName: "Array",
                outputVar: elementVar
            );

            return $$"""
                     double {{doubleLengthVar}} = global::Iskra.JSCore.Extensions.JSObjectPropertyExtensions.GetPropertyAsDoubleV2(input, "length");
                     int {{lengthVar}} = global::System.Convert.ToInt32({{doubleLengthVar}});

                     {{returnTypeDeclaration}} {{resVar}} = new {{elementTypeDeclaration}}[{{lengthVar}}];
                     for (int {{indexVar}} = 0; {{indexVar}} < {{lengthVar}}; {{indexVar}}++)
                     {
                         {{elementTypeDeclaration}} {{elementVar}};
                     {{getElementContent.IndentLines(4)}}
                         {{resVar}}[{{indexVar}}] = {{elementVar}};
                     }

                     return {{resVar}};
                     """;
        }

        logger.LogWarning("GenericMarshaller ToManaged for type {input} not supported.", input);
        return "throw new NotImplementedException();";
    }

    private string GenerateToJS(IDLTypeDescription input)
    {
        var setPropertyValueGenerator = provider.GetRequiredService<SetPropertyValueGenerator>();

        if (input is FrozenArrayTypeDescription frozenArray)
        {
            var elementType = frozenArray.IdlType.Single();
            var resVar = generatorContext.GetNextVariableName("res");
            var indexVar = generatorContext.GetNextVariableName("i");

            var setElementContent = setPropertyValueGenerator.Generate(
                inputVar: resVar,
                valueVar: $"input[{indexVar}]",
                type: elementType,
                propertyNameVar: $"{indexVar}.ToString()",
                isStatic: false,
                containingTypeName: "Array"
            );

            return $$"""
                     global::System.Runtime.InteropServices.JavaScript.JSObject {{resVar}} = ConstructArray(global::System.Runtime.InteropServices.JavaScript.JSHost.GlobalThis, "Array", input.Length);

                     for (int {{indexVar}} = 0; {{indexVar}} < input.Length; {{indexVar}}++)
                     {
                     {{setElementContent.IndentLines(4)}}
                     }

                     return {{resVar}};
                     """;
        }

        if (input is SequenceTypeDescription sequence)
        {
            var elementType = sequence.IdlType.Single();
            var resVar = generatorContext.GetNextVariableName("res");
            var indexVar = generatorContext.GetNextVariableName("i");

            var setElementContent = setPropertyValueGenerator.Generate(
                inputVar: resVar,
                valueVar: $"input[{indexVar}]",
                type: elementType,
                propertyNameVar: $"{indexVar}.ToString()",
                isStatic: false,
                containingTypeName: "Array"
            );

            return $$"""
                     global::System.Runtime.InteropServices.JavaScript.JSObject {{resVar}} = ConstructArray(global::System.Runtime.InteropServices.JavaScript.JSHost.GlobalThis, "Array", input.Length);

                     for (int {{indexVar}} = 0; {{indexVar}} < input.Length; {{indexVar}}++)
                     {
                     {{setElementContent.IndentLines(4)}}
                     }

                     return {{resVar}};
                     """;
        }

        logger.LogWarning("GenericMarshaller ToJS for type {input} not supported.", input);
        return "throw new NotImplementedException();";
    }
}