using System.Runtime.InteropServices.JavaScript;
using Iskra.StdWebGenerator.Extensions;
using Iskra.StdWebGenerator.Marshalling;

namespace Iskra.StdWebGenerator;

public class ObjectMethodsContext(
    GeneratorContext context
)
{
    private class Function<TInfo>
    {
        public required TInfo Info { get; init; }

        public string Code { get; set; } = string.Empty;
    }

    private readonly List<Function<JSObjectMethodCallInfo>> _methodCalls = [];
    private readonly List<Function<JSObjectMethodApplyInfo>> _methodApplys = [];

    public string ClassCode
    {
        get
        {
            var callMembers = string.Join("\n\n", _methodCalls.Select(x => x.Code));
            var applyMembers = string.Join("\n\n", _methodApplys.Select(x => x.Code));

            return $$"""
                     // <auto-generated/>

                     using System.Runtime.InteropServices.JavaScript;

                     namespace Iskra.StdWeb;

                     #nullable enable

                     internal static partial class {{ClassName}}
                     {
                     {{callMembers.IndentLines(4)}}
                     {{applyMembers.IndentLines(4)}}
                     }
                     """;
        }
    }

    public string ClassName => "JSObjectCustomMethodsExtensions";

    public JSObjectMethodCallInfo GetMethodCallInfo(
        IReadOnlyList<MyType> parameters,
        MyType? returnParam
    )
    {
        JSObjectMethodCallInfo? info = _methodCalls
            .Select(x => x.Info)
            .SingleOrDefault(x => x.Parameters.SequenceEqual(parameters) && x.ReturnParam == returnParam);

        if (info is null)
        {
            info = new(
                Name: $"CustomMethodCall_{_methodCalls.Count}",
                Parameters: parameters,
                ReturnParam: returnParam
            );

            var func = new Function<JSObjectMethodCallInfo>
            {
                Info = info,
            };

            _methodCalls.Add(func);

            func.Code = GenerateCustomMethodCall(info);
        }

        return info;
    }

    public JSObjectMethodApplyInfo GetMethodApplyInfo(
        MyType paramsElement,
        MyType? returnParam
    )
    {
        var info = _methodApplys
            .Select(x => x.Info)
            .SingleOrDefault(x => x.ParamsElement == paramsElement && x.ReturnParam == returnParam);

        if (info is null)
        {
            info = new(
                Name: $"CustomMethodApply_{_methodApplys.Count}",
                ParamsElement: paramsElement,
                ReturnParam: returnParam
            );

            var func = new Function<JSObjectMethodApplyInfo>
            {
                Info = info,
            };

            _methodApplys.Add(func);

            func.Code = GenerateCustomMethodApply(info, context);
        }

        return info;
    }

    private static string GenerateCustomMethodCall(JSObjectMethodCallInfo method)
    {
        var returnTypeName = method.ReturnParam is null ? "void" : TypeNameGenerator.Execute(method.ReturnParam);

        var parameters = method.Parameters.Select((x, i) => $"{TypeNameGenerator.Execute(x)} arg{i}");
        var parametersForCall = method.Parameters.Select((x, i) => $"arg{i}");
        var parametersList = string.Join(", ", ["this JSObject obj", "string methodName", ..parameters]);

        var jsImportParameters = method.Parameters.Select((x, i) =>
            $"{GetMarshallAttributeIfNeeded(x)}{TypeNameGenerator.Execute(x)} arg{i}");
        var jsImportParametersList = string.Join(", ", ["JSObject func", "JSObject obj", ..jsImportParameters]);
        var jsImportCallParametersList = string.Join(", ", ["method", "obj", ..parametersForCall]);

        return
            $$"""
              [JSImport("globalThis.Function.prototype.call.call")]
              private static partial {{returnTypeName}} _{{method.Name}}({{jsImportParametersList}});

              public static {{returnTypeName}} {{method.Name}}({{parametersList}})
              {
                  var method = obj.GetPropertyAsJSObject(methodName)
                               ?? throw new Exception($"Method {methodName} not found.");
                               
                  {{(method.ReturnParam is null ? "" : "return ")}}_{{method.Name}}({{jsImportCallParametersList}});
              } 
              """;
    }

    private string GenerateCustomMethodApply(JSObjectMethodApplyInfo method, GeneratorContext context)
    {
        var returnTypeName = method.ReturnParam is null ? "void" : TypeNameGenerator.Execute(method.ReturnParam);

        var parametersType = new MyType(
            Type: typeof(IReadOnlyList<>).MakeGenericType(method.ParamsElement.Type),
            IsNullable: false,
            ElementType: null,
            GenericTypeArguments: [method.ParamsElement]
        );
        var parameters = $"{TypeNameGenerator.Execute(parametersType)} args";
        var parametersList = string.Join(", ", "this JSObject obj", "string methodName", parameters);

        var marshalledParametersVar = context.GetNextVariableName();

        var jsImportParametersType = new MyType(
            Type: typeof(JSObject),
            IsNullable: false,
            ElementType: null,
            GenericTypeArguments: []
        );
        var jsImportParameters = $"{TypeNameGenerator.Execute(jsImportParametersType)} args";
        var jsImportParametersList = string.Join(", ", "JSObject func", "JSObject obj", jsImportParameters);
        var jsImportCallParametersList = string.Join(", ", "method", "obj", marshalledParametersVar);

        var marshalledParameters = $$"""
                                     {{TypeNameGenerator.Execute(jsImportParametersType)}} {{marshalledParametersVar}};
                                     {{Marshallers.Instance
                                         .GetNext(parametersType, jsImportParametersType)
                                         .Marshall(parametersType, "args", jsImportParametersType, marshalledParametersVar, context)}}
                                     """;

        return
            $$"""
              [JSImport("globalThis.Reflect.apply")]
              private static partial {{returnTypeName}} _{{method.Name}}({{jsImportParametersList}});

              public static {{returnTypeName}} {{method.Name}}({{parametersList}})
              {
                  var method = obj.GetPropertyAsJSObject(methodName)
                               ?? throw new Exception($"Method {methodName} not found.");

              {{marshalledParameters.IndentLines(4)}}
                  {{(method.ReturnParam is null ? "" : "return ")}}_{{method.Name}}({{jsImportCallParametersList}});
              }
              """;
    }

    private static string GetMarshallAttributeIfNeeded(MyType type)
    {
        if (type.Type == typeof(ObjectForJS))
        {
            return "[JSMarshalAs<JSType.Any>] ";
        }

        return "";
    }
}