using Iskra.StdWebGenerator.Extensions;
using Iskra.StdWebGenerator.JSObjectMarkers;

namespace Iskra.StdWebGenerator.GeneratorContexts;

public class ObjectMethodsContext(
    GeneratorContext context
)
{
    private class Function<TInfo>
    {
        public required TInfo Info { get; init; }

        public string Code { get; set; } = string.Empty;
    }

    private readonly List<Function<JSObjectMethodCallInfo>> _methodCalls = [];

    public string ClassCode
    {
        get
        {
            var callMembers = string.Join("\n\n", _methodCalls.Select(x => x.Code));

            return $$"""
                     // <auto-generated/>

                     using System.Runtime.InteropServices.JavaScript;

                     namespace Iskra.StdWeb;

                     #nullable enable

                     internal static partial class {{ClassName}}
                     {
                     {{callMembers.IndentLines(4)}}
                     }
                     """;
        }
    }

    public string ClassName => "JSObjectCustomMethodsExtensions";

    public JSObjectMethodCallInfo GetMethodCallInfo(
        IReadOnlyList<MyType> parameters,
        MyType? returnParam
    )
    {
        JSObjectMethodCallInfo? info = _methodCalls
            .Select(x => x.Info)
            .SingleOrDefault(x => x.Parameters.SequenceEqual(parameters) && x.ReturnParam == returnParam);

        if (info is null)
        {
            info = new(
                Name: $"CustomMethodCall_{_methodCalls.Count}",
                Parameters: parameters,
                ReturnParam: returnParam
            );

            var func = new Function<JSObjectMethodCallInfo>
            {
                Info = info,
            };

            _methodCalls.Add(func);

            func.Code = GenerateCustomMethodCall(info);
        }

        return info;
    }

    private static string GenerateCustomMethodCall(JSObjectMethodCallInfo method)
    {
        var returnTypeName = method.ReturnParam is null ? "void" : TypeNameGenerator.Execute(method.ReturnParam);

        var parameters = method.Parameters.Select((x, i) => $"{TypeNameGenerator.Execute(x)} arg{i}");
        var parametersForCall = method.Parameters.Select((x, i) => $"arg{i}");
        var parametersList = string.Join(", ", ["this JSObject obj", "string methodName", ..parameters]);

        var jsImportParameters = method.Parameters.Select((x, i) =>
            $"{GetMarshallAttributeIfNeeded(x)}{TypeNameGenerator.Execute(x)} arg{i}");
        var jsImportParametersList = string.Join(", ", ["JSObject func", "JSObject obj", ..jsImportParameters]);
        var jsImportCallParametersList = string.Join(", ", ["method", "obj", ..parametersForCall]);

        return
            $$"""
              [JSImport("globalThis.Function.prototype.call.call")]
              private static partial {{returnTypeName}} _{{method.Name}}({{jsImportParametersList}});

              public static {{returnTypeName}} {{method.Name}}({{parametersList}})
              {
                  var method = obj.GetPropertyAsJSObject(methodName)
                               ?? throw new Exception($"Method {methodName} not found.");
                               
                  {{(method.ReturnParam is null ? "" : "return ")}}_{{method.Name}}({{jsImportCallParametersList}});
              } 
              """;
    }

    private static string GetMarshallAttributeIfNeeded(MyType type)
    {
        if (type.Type == typeof(ObjectForJS))
        {
            return "[JSMarshalAs<JSType.Any>] ";
        }

        return "";
    }
}